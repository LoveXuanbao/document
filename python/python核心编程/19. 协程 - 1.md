## 协程 - `asyncio` - 1

为什么我们要学习异步编程

- 异步非阻塞、`asyncio`
- `tornado`、`fastapi`、`django3`、`aiothttp`.....

以上框架都在逐步支持异步特性，目前`python`本身也在向异步方向发展，作为开发者还是有必要去学习异步开发的



学习步骤：

1. 什么是协程
2. `asyncio`模块
3. 实战案例



#### 协程

协程不是计算机提供，操作系统只是提供了线程和进程。程序员人为创造。

协程运行程序的大致状态：在一个线程中运行多个任务，任务与任务之间来回切换，并在同一时间内只能运行一个任务。

协程（coroutine）也可以被称之为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行。

```python
def func1():
    print(1)
	print(2)

def func2():
    print(3)
    print(4)


func1()
func2()
```

实现协程有以下几种方式：

- `greenlet` - 早期模块
- `yield` 关键字
- `asyncio` 装饰器 - 早期python版本（python3.4）
- `async`、`await` 关键字（python3.5）



##### `greenlet` 实现协程

```python
# pip install greenlet

from greenlet import greenlet


def func1():
    print(1)
    gr2.switch()
    print(2)
    gr2.switch()


def func2():
    print(3)
    gr1.switch()
    print(4)


gr1 = greenlet(func1)
gr2 = greenlet(func2)
gr1.switch()

```

 

##### `yield`关键字实现协程

```python
def func1():
    yield 1
    yield from func2()
    yield 2
    
def func2():
    yield 3
    yield 4
    
f1 = func1()
for item in f1:
    print(item)
```



##### `asyncio` 

需要在python3.4及以上版本使用

```python
import asyncio


@asyncio.coroutine
def func1():
    print(1)
    yield from asyncio.sleep(2)
    print(2)


@asyncio.coroutine
def func2():
    print(3)
    yield from asyncio.sleep(2)
    print(4)


tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2())
]

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
```

注意：以上代码为遇到`IO阻塞`则自动切换任务。



##### `async` & `await` 关键字

需要在python3.5及以上版本使用

```python
import asyncio


async def func1():
    print(1)
    await asyncio.sleep(2)
    print(2)


async def func2():
    print(3)
    await asyncio.sleep(2)
    print(4)


tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2())
]

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
```



#### 协程意义

在一个线程中如果遇到了`IO等待`的时间，那么线程会充分利用这个等待时间去执行其他的任务。

案例：使用`requests`模块完成图片下载

- 普通方式

  ```python
  # pip install requests
  import requests
  
  
  def download_image(url):
      print('开始下载: ', url)
      response = requests.get(url)
      print('下载完成...')
  
      # 保存图片
      file_name = url.rsplit('/')[-1]
      with open(file_name, mode='wb') as f:
          f.write(response.content)
  
  
  if __name__ == '__main__':
      url_list = [
          'http://pic.bizhi360.com/bbpic/98/10798.jpg',
          'http://pic.bizhi360.com/bbpic/92/10792.jpg',
          'http://pic.bizhi360.com/bbpic/86/10386.jpg'
      ]
      for item in url_list:
          download_image(item)
  ```

  

- 协程方式

  ```python
  import aiohttp
  import asyncio
  
  
  async def download_image(session, url):
      print('发送请求: ', url)
      async with session.get(url, verify_ssl=False) as response:
          content = await response.content.read()
          file_name = url.rsplit('/')[-1]
          with open(file_name, mode='wb') as f:
              f.write(content)
  
  
  async def main():
      async with aiohttp.ClientSession() as session:
          url_list = [
              'http://pic.bizhi360.com/bbpic/98/10798.jpg',
              'http://pic.bizhi360.com/bbpic/92/10792.jpg',
              'http://pic.bizhi360.com/bbpic/86/10386.jpg'
          ]
  
          tasks = [asyncio.create_task(download_image(session, url)) for url in url_list]
          await asyncio.wait(tasks)
  
  
  if __name__ == '__main__':
      asyncio.run(main())
  ```



#### 异步编程

##### 事件循环

事件循环是异步编程中的重要的组成部分，大家现在可以暂时理解为一个死循环，可以检测并执行某些代码。

```python
# 伪代码
任务列表 = [任务1, 任务2, 任务3...]

while True:
    可执行的任务列表, 已完成的任务列表 = 去任务列表中检查所有的任务, 将'可执行'和'已完成'的任务返回
    
    for 就绪任务 in 可执行的任务列表:
        执行已就绪的任务
        
    for 已完成的任务 in 已完成的任务列表:
        在任务列表中移除已完成的任务
        
    如果任务列表中的任务都已经完成则终止循环
```

```python
import asyncio


# 生成或者获取一个事件循环
loop = asyncio.get_event_loop()
# 将任务放到事件循环[任务列表]中检测任务状态是否可执行
loop.run_until_complete(任务)
```



##### 基本应用

- 协程函数：在定义函数时使用`async def 函数名()`修饰的函数被称之为协程函数
- 协程对象：执行 `协程函数()` 得到的就是协程对象

```python
# 定义协程函数
async def func():
    pass
  
# 获取协程对象
result = func()
```

注意：在获取协程对象时 协程函数的内部代码并不会被执行。



想要执行协程函数，需要使用协程函数、协程对象、事件循环搭配使用。

事件循环会执行协程函数中的内部代码。

```python
import asyncio

async def func():
    print('这是一个协程任务')
    
result = func()
loop = asyncio.get_event_loop()
loop.run_until_complete(result)
```

在python3.7之后无需自己创建事件循环, 可以直接使用`asyncio.run(任务)`来执行协程函数中的内部代码

```python
import asyncio

async def func():
    print('这是一个协程任务')
    
result = func()
asyncio.run(result)
```



##### await 关键字

- await 定义：等待某些IO任务

- 基本使用方式：await + 可等待的对象（协程对象、`Future`对象、`Task`对象）

    

  示例1：

  ```python
  import asyncio
  
  
  async def func():
      print('开始协程任务...')
      # 模拟IO等待 如果当前有其他任务则切换
      response = await asyncio.sleep(2)
      print('任务结束: ', response)
      
  asyncio.run(func())
  ```

  

  示例2：

  ```python
  import asyncio
  
  
  async def others():
      print('start')
      await asyncio.sleep(2)
      print('end')
      return '这是执行完协程函数后所得到的结果'
    
    
  async def func():
      print('执行协程函数内部代码')
      response = await others()
      print(response)
  
  asyncio.run(func())
  ```

  

  示例3：

  ```python
  import asyncio
  
  
  async def others():
      print('start')
      await asyncio.sleep(2)
      print('end')
      return '这是执行完协程函数后所得到的结果'
    
    
  async def func():
      print('执行协程函数内部代码')
      # 注意：在当前代码中使用await进行io等待后, 会堵塞代码。当response_1执行完毕后解堵塞继续往下执行
      response_1 = await others()
      print(response_1)
      
      # response_2同理, 等待others任务执行完毕后才能继续往下执行
      response_2 = await others()
      print(response_2)
  
  asyncio.run(func())
  ```

  await就是等待对象执行完毕并得到返回值之后才会继续向下执行。



##### Task 对象

> Tasks用于并发调度协程，通过`asyncio.create_task(协程对象)`的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。
>
> 除了使用`asyncio.create_task()`函数外，还可以使用低层级的`loop.create_task()`或`ensure_future()`函数。但是不建议手动实例化Task对象



注意：`asyncio.create_task()`函数在 Python 3.7 中被加入。在 Python 3.7 之前可以改用低层级的`asyncio.ensure_future()`函数



实例1：

```python
import asyncio

async def func():
    print(1)
    await asyncio.sleep(2)
    print(2)
    return '这是一个返回值'
  
async def main():
    print('开始任务...')
    # 创建task对象，将当前的func任务添加到事件循环中
    task_1 = asyncio.create_task(func())
    task_2 = asyncio.create_task(func())
    print('任务结束...')
    
    # 当执行某些协程遇到IO操作时，会自动切换执行其他任务
    # 此处的await是等待相对应的协程全部执行完毕并获取结果
    result_1 = await task_1
    result_2 = await task_2
    print(result_1, result_2)

asyncio.run(main())    
```



示例2：

```python
import asyncio


async def func():
    print(1)
    await asyncio.sleep(2)
    print(2)
    return '这是一个返回值'


async def main():
    print('开始任务...')
    # 创建task对象，将当前的func任务添加到事件循环中
    task_list = [
        # 在创建task对象时, 可以在task内部给协程对象取别名: name=别名名称
        asyncio.create_task(func(), name='n1'),
        asyncio.create_task(func(), name='n2')
    ]
    print('任务结束...')
    # await 关键字之后只能连接可以等待的对象 列表不能在await之后
    # await task_list
    done, pending = await asyncio.wait(task_list, timeout=None)
    '''
    done: 接收协程函数所返回的值
    pending: 如果设置超时时间, 则接收在超时时间内没有执行完毕的函数的状态

    一般情况下不会使用pending参数
    '''
    print(done)  # 返回的类型为一个集合
    
    for item in done:  # 使用迭代的方式取出集合中的协程对象
        print(item.result())


asyncio.run(main())
```



示例3：

```python
import asyncio


async def func():
    print(1)
    await asyncio.sleep(2)
    print(2)
    return '这是一个返回值'

task_list = [
    func(),
    func()
]
 
done, pending = asyncio.run(asyncio.wait(task_list))
print(done)
```

注意点：

- 如果需要将`task`列表放在函数外，需要注意在执行协程函数列表之前需要首先创建事件循环。

- 并且在列表中不能直接添加`Task`对象。`Task`对象需要基于事件循环执行。