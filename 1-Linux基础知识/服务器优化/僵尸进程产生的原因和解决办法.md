# 僵尸进程产生的原因

​        僵尸进程就是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程的资源，此时子进程将成为一个僵尸进程。

​        僵尸进程已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态信息供其他进程收集，除此之外，僵尸进程不再占有任何存储空间。它需要它的父进程来为它收尸，如果父进程没有安装SIGCHLD信号处理函数调用**wait**或**waitpid()**等待子进程结束，也没有显式忽略该信号，那么它就一直保持僵尸状态该，如果这个时候父进程结束了，那么init进程会自动接手这个进程，为它收尸，还是能被清除掉的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是系统中为什么又时候会又很多的僵尸进程。

1. 运行一个程序时，它会产生一个父进程以及很多子进程。所有这些子进程都会消耗内核分配给他们的内存和CPU资源；
2. 这些子进程完成后会发送一个Exit信号然后死掉，这个Exit信号需要被父进程所读取，父进程需要随后调用wait命令来读取子进程的退出状态，并将子进程从进程表中移除；
3. 若父进程正确读取了子进程的Exit信号，则子进程会从进程表中删掉；
4. 但是若父进程未能读取到子进程的Exit信号，则这个子进程虽然完成执行处于死亡的状态，但也不会从进程表中删掉。

# 僵尸进程的危害

​        在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括**进程号PID**，**退出状态the termination status of the process**，**运行时间the amount of CPU time taken bu the process**等），直到父进程通过**wait/waitpid()**来取时才释放。

​        如果进程不调用**wait/waitpid()**的话，那么保留的那段信息就不会被释放，其进程号就会一直被占用，但是系统所能使用的进程号时有限的，如果产生大量的僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

​        当系统中出现僵尸进程的时候，是无法通过**kill**命令把它清理掉的，但是可以杀死它的父进程，让它变成孤儿进程，并进一步被系统中管理孤儿进程的init进程收养并清理。

# 查看服务器僵尸进程的父进程

- 使用top命令查看服务器当前僵尸进程又4万6

![image-20230825114718628](https://niuzhan-1306014148.cos.ap-beijing.myqcloud.com/Typora/image-20230825114718628.png)

- 使用**ps aux | grep Z | more**查看进程PID号，因为僵尸进程太多，不加more命令的话，页面要刷很久，所以我们只看开头即可

![image-20230825114806251](https://niuzhan-1306014148.cos.ap-beijing.myqcloud.com/Typora/image-20230825114806251.png)

- 使用**ps -ef | grep 进程PID**查看子进程的父进程号

![image-20230825114857536](https://niuzhan-1306014148.cos.ap-beijing.myqcloud.com/Typora/image-20230825114857536.png)

- 因为我这个服务器上的服务都是docker部署，所以使用下面命令批量查看各个容器的进程PID

```bash
for i in $(docker ps -a | awk '(NR>1){print $1}'); do echo $(docker inspect -f '{{.State.Pid}}' $i) $i;done
```

![image-20230825115020017](https://niuzhan-1306014148.cos.ap-beijing.myqcloud.com/Typora/image-20230825115020017.png)

- 第一列是进程PID，第二列是容器ID，然后执行**docker ps -a | grep 容器ID**查看具体服务信息，如果是公司自己研发的服务，找相应的开发查看代码解决。