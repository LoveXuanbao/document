# CentOS (缓冲buff/缓存cache)介绍及优化

## 缓存机制

- 在Linux系统中，为了提高文件系统性能，内核利用一部分物理内存分配出缓冲区，用户缓存系统操作和数据文件，当内核收到读写的请求时，内核先去缓存区找是否有请求的数据，有就直接返回，如果没有则通过驱动程序去硬盘查找。
- 缓存机制优点：减少系统调用次数，降低CPU上下文切换和磁盘访问频率；
- CPU上下文切换：CPU给每个进程一定的服务时间，当时间片用完后，内核从正在运行的进程中收回处理器。同时把进程当前运行状态保存下来，然后加载下一个任务，这个过程叫做上下文切换，实质上就是被终止运行进程和运行进程的进程切换；
- SWAP用途：SWAP意思是交换分区，通常我们说的虚拟内存，是从硬盘中划分出的一起分区。当物理内存不够用的时候，内核就会释放缓存区（buff/cache）里一些长时间不用的程序，然后将这写程序临时放到swap中，也就说如果物理内存和缓存区内存不够用的时候，才会用到swap

### 缓冲（buff）

- 主要用于I/O写，CPU 往磁盘中保存数据的时候，不是直接和磁盘打交道，而是先把数据给内存，内存在自己的一片区域中把这个数据保存下来，这个区域被称之为缓冲buff。
- 主要用于I/O写，根据磁盘的读写设计，把分散的写操作集中进行，减少磁盘碎片和磁盘的反复寻道，从而提高系统性能。可以通过sync命令手动清空缓冲。
- 用于存储速度不同步的设备或优先级不同的设备直接传输数据的区域。通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备于存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备在读取buffer的数据，在此期间存储快的设备CPU可以干其他的事情。

### 缓存（cache）

- CPU缓存，（CPU cache），一级缓存、二级缓存、三级缓存，在一级缓存之上还有寄存器，寄存器的速度能跟CPU的速度一样，一级缓存（又分为指令缓存和数据缓存）比CPU慢，二级缓存比一级慢、三级更慢、最慢的是内存。内存也是最大的缓存。

- 数据交换的缓冲区（称作cache），高速缓存，是位于CPU于主内存之间的一种容量较小但速度很高的存储器，由于CPU的速度远高于主内存，CPU直接从内存中存取数据需要等待一定的时间周期，cache中保存着CPU刚用过或循环使用的一部分数据。当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。起到内存和CPU之间的缓冲作用，缓解内存和CPU速度不匹配问题，起到提高CPU执行效率。缓存遵循的是程序的局部性原理。
- 从内存读取于磁盘读取角度考虑，cache可以理解为操作系统为了更高的读取效率，更多的使用内存来缓存可能被再次访问的数据。
- cache并不是缓存文件的，而是缓存块的（块是I/O读写最小的单元），cache一般会用在I/O请求上，如果多个进程要访问某个文件，可以把此文件读入cache中，这样下一个进程获取CPU控制权并访问此文件直接从cache获取，提高读写性能。

### 缓冲（buff）与缓存（cache）的区别

- buffer和cache的相同点：都是2个层面之间的中间层，都是内存；
- buffer和cache的不同点：buffer解决的是空间问题，cache解决的是时间问题；

- buffer是I/O缓存，为了给数据找一个暂存空间，引入了buffer中间层，用于内存和硬盘的缓冲；
- cache 是高速缓存，为了提高速度，引入了cache中间层，用于CPU和内存之间的缓冲；
- 为了解决2个不同维度的问题（时间，空间）恰巧取了同一种解决方法，加入一个中间层，先数据写到中间层上，然后在写入目标，这个中间层就是内存"RAM"，既然是存储器就是两个参数：写入的速度，存储的容量。cache利用的RAM提供的高读写速度，buffer利用的RAM提供的存储容量。

> - buffer（缓冲）是系统两端处理速度平衡时使用的，他的引入时为了减小短期内突发I/O的影响，起到流量整形的作用，比如生产者---消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。
> - cache（缓存）是系统两端处理速度不匹配时的一种折中策略，因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响.
> - 假设以后存储器访问变得跟CPU做计算一样快，cache就可以消失，但是buffer依然存在，比如从网络上下载东西，瞬时速率可能会有较大变化，但从长期来看确实稳定的，这样就能通过引入一个buffer是的OS接受数据的速率更稳定，进一步减少对磁盘的危害，延长磁盘使用寿命。

# 缓存的优化

## 释放缓存区内存的方法

### 1. 临时释放

```
## 清理pagecache（页面缓存）
[root@localhost ~]# echo 1 > /proc/sys/vm/drop_caches
或者
[root@localhost ~]# sysctl -w vm.drop_caches=1
vm.drop_caches = 1

## 清理dentries（目录缓存）和inodes
[root@localhost ~]# echo 2 > /proc/sys/vm/drop_caches
或者
[root@localhost ~]# sysctl -w vm.drop_caches=2
vm.drop_caches = 2

## 清理pagecache、dentries和inodes
[root@localhost ~]# echo 3 > /proc/sys/vm/drop_caches
或者
[root@localhost ~]# sysctl -w vm.drop_caches=3
vm.drop_caches = 3
```

### 3. 永久释放

```
## 在 /etc/sysctl.conf 中添加以下配置
vm.drop_caches=1/2/3     ## 1,2,3对应临时释放的解释，选择合适的添加
```

# 注意事项

释放的操作在多数情况下都不会对系统造成伤害，智慧有助于释放不用的内存；但是如果在执行这些操作时正在写数据，那么实际上在数据到达磁盘之前就将它从文件缓存中清楚掉了，这样可能会造成不好的影响。

如果要避免这种情况，应该告诉内核，当清理inode/dentry缓存时应该用什么样的优先级；

查看优先级

```
[root@localhost ~]# cat /proc/sys/vm/vfs_cache_pressure
100
```

vfs_cache_pressure这个值一般默认为100，内核会尝试重新声明dentries和inodes，并采用一种相对于页面缓存和交换缓存比较合理的比例。

- 减少vfs_cache_pressure的值，会导致内核倾向于保留dentries和inodes缓存；
- 增加vfs_cache_pressure的值，即超过100时，则会导致内核倾向于重新生命dentries和inodes
- 小于100的值不会导致缓存的大量减少；
- 超过100的值则会告诉内核你希望以高优先级来清理缓存